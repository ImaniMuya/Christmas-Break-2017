<html>

<div style="text-align:center; margin:30px;">
<canvas id="canvas" width="600" height="600" style="margin:auto;">
	Your browser doesn't support canvas!
</canvas>
</div>


<script>
const FRICTION = .9;
const GRAVITY = 2.5;
const pause = 8;

var ticks = 0;
var backColor = '#777';
var ctx = canvas.getContext("2d");

var lives = 3; 

var keys = {};

var floor = 450;
var ceiling = 150;

var floorSpikes = [];
var ceilingSpikes = [];

var fSpikeTimer = Math.floor(Math.random() * 100);
var cSpikeTimer = Math.floor(Math.random() * 100);

var camera = {
	x: 0,
	vx: 1,
	update: function() {
		this.vx += 0.001
		this.x += this.vx;
		player.x += this.vx;
		fSpikeTimer-= this.vx;
		cSpikeTimer-= this.vx;
	}
}

var player = {
	x: 20,
	y: 300,
	h: 60,
	w: 30,
	color: 'red',
	vx: 0,
	vy: 0,
	maxv: 9,
	ax: 2,
	jumps: 2,
	draw: function(ctx) {
		ctx.fillStyle=this.color;
		ctx.fillRect(this.x - camera.x, this.y, this.w, this.h);
	},
	update: function() {
		if (keys[37]) { //left
			this.vx -= this.ax;
			if (this.vx < -this.maxv)
				this.vx = -this.maxv;
		}
		if (keys[39]) { //right
			this.vx += this.ax;
			if (this.vx > this.maxv)
				this.vx = this.maxv;
		}
		this.h = 60;
		if (keys[40]) { //down
			this.vy += GRAVITY;
			this.h = 30;
			this.y += 30;
		}

		this.x += this.vx;
		this.y += this.vy;
		this.vx *= FRICTION;
		if (this.y < ceiling) {
			this.y = ceiling;
			this.vy = 0;
		}
		else if (this.y < floor - this.h) { //above floor
			this.vy += GRAVITY;
		} else { //collision
			this.vy = 0;
			this.y = floor - this.h;
			this.jumps = 2;
		}
	}
}

function drawFloor(ctx) {
	ctx.fillStyle = 'black';
	ctx.fillRect(0, floor, canvas.width, canvas.height-floor)
}
function drawCeiling(ctx) {
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, canvas.width, ceiling)
}

function drawBackground(ctx) {
	ctx.fillStyle=backColor;
	ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawStats(ctx) {
	ctx.font = '24px serif';
	ctx.fillStyle = 'yellow';
	ctx.textAlign = 'left';
	ctx.fillText("Lives: " + lives, 10, 30)
}

function newFloorSpike(x, h) {
	return {
		x : x,
		y : floor-h, 
		w : 30,
		h : h,
		touched : false, 
		color : 'blue',
		draw : function (ctx) {
			ctx.fillStyle = this.color; 
			ctx.fillRect(this.x - camera.x, this.y, this.w, this.h)
		},
		update : function() {
			let dx = Math.abs(this.x - player.x);
			let dy = Math.abs(this.y - player.y);
			if (dx < player.w && dy < player.h) {
				this.color = 'green';
				if (!this.touched) {
					lives--;
					this.touched = true;
				} 
			}
		}
	}
}

function newCeilingSpike(x, h) {
	return {
		x : x,
		y : ceiling, 
		w : 30,
		h : h,
		touched : false, 
		color : 'blue',
		draw : function (ctx) {
			ctx.fillStyle = this.color; 
			ctx.fillRect(this.x - camera.x, this.y, this.w, this.h)
		},
		update : function() {
			let dx = Math.abs(this.x - player.x);
			let dy = Math.abs(this.y - player.y);
			if (dx < player.w && dy < this.h) {
				this.color = 'green';
				if (!this.touched) {
					lives--;
					this.touched = true;
				} 
			}
		}
	}
}

onkeydown = function(e) {
	if (player.jumps && e.keyCode == 38 && !keys[38]) { //up
		player.vy = -25;
		player.jumps--;
	}
	keys[e.keyCode] = true;
}

onkeyup = function(e) {
	keys[e.keyCode] = false;
}

function draw() {
	drawBackground(ctx);
	
	player.draw(ctx);
	drawFloor(ctx);
	drawCeiling(ctx);
	for (let spike of floorSpikes) {
		spike.draw(ctx);
	}
	for (let spike of ceilingSpikes) {
		spike.draw(ctx);
	}
	drawStats(ctx);
}

function update() { 
//TODO: Score
//TODO: healing
//TODO: clean-up 
//TODO: rotation
//TODO: sprites 
	player.update();
	camera.update();
	for (let spike of floorSpikes) {
		spike.update();
	}
	for (let spike of ceilingSpikes) {
		spike.update();
	}

	if (fSpikeTimer <= 0) {
		let h = 30 + Math.floor(Math.random()*100)
		floorSpikes.push(newFloorSpike(camera.x + 600,h))
		fSpikeTimer = 200 + Math.floor(Math.random()*300);
	}	
	if (cSpikeTimer <= 0) {
		let h = 30 + Math.floor(Math.random()*100)
		ceilingSpikes.push(newCeilingSpike(camera.x + 600,h))
		cSpikeTimer = 200 + Math.floor(Math.random()*300);
	}
}

function tick() {
	ticks++;
	if (ticks >= pause) {
		ticks = 0;
		draw();
		update();
	}
}
setInterval(tick, 1)
</script>

</html>
